1)What is the distinction between a list and an array?
List
1)Contains elements of different data types
2)Explicitly importing module is not required to declare a list
3)Cannot handle arithmetic operations
4)Can be nested inside another list
5)Mostly used in the shorter sequence of data elements

Array
1)Contains elements of same data types
2)Need to import the module explicitly to declare an array
3)Can handle arithmetic operations
4)Must contain all elements of the same size
5)Mostly used in the longer sequence of data elements


2)What are the qualities of a binary tree?
1. The number of external nodes is 1 more than the number of internal nodes
2.  The number of external nodes is at least h + 1, where h is the height of the tree, and at most 2h . 
3.  The number of internal nodes is at least h and at most 2h - 1.
4.  The total number of nodes in a binary tree is at least 2*h + 1 and at most  2h+1 - 1.
5.  The height, h, of a binary tree with n nodes is at least log n+1  and at most n.
6.  A binary tree with n nodes has exactly n - 1 edges.

3)What is the best way to combine two balanced binary search trees?
Approach 1
In this approach, we will take all the elements of the first binary search tree one by one, and insert them into the second binary search tree. As we know, inserting an element in a self-balancing binary search tree takes log(N) time, where N is the size of the binary search tree. To optimize the time complexity, we will pick the smaller tree as the first tree.

This method takes O(Nlog(N)) time.

Algorithm
Traverse through the smaller BST and insert all of its elements into the second BST.
The insertion in a BST takes O(log(N)) time, so the total time complexity of this approach is O(Nlog(N)).


Approach#2
In this approach, we are going to use a doubly-linked list to merge the given trees in place. First, we will convert the given two binary search trees into doubly-linked lists. Then, we will merge those two doubly-linked lists. Finally, we will build a balanced binary search tree from the merged doubly linked list.

This method takes O(M+N) time, M and N are the size of the trees.

Algorithm
Convert the given two Binary Search Trees to doubly linked lists in place.
Merge the two sorted doubly-linked lists;
Make a balanced Binary Search Tree from the merged doubly linked list.


Approach#3
In this approach, we are going to store the in-order traversal of both the binary search trees in two arrays A_1 and A_2. Now, We will create a new array, which will contain all the elements of both A_1 and A_2 in a sorted way. Finally, we will convert the sorted array into a balanced binary search tree, hence the two binary search trees are merged.

This solution takes O(M+N) time, M and N are the size of the trees.

Algorithm
Store the in-order traversal of both the binary search trees in two arrays, say A_1 and A_2.
Now, create a new array A_3, and insert the elements of A_1 and A_2 in A_3, in the sorted manner.

4)How would you describe Heap in detail?
Heaps are advanced data structures that are useful for specific use-cases such as sorting and implementing priority queues.

Characteristics
Heaps can be thought of as regular binary trees with two special characteristics.

Heaps must be Complete Binary Trees.
The nodes must be ordered according to the Heap order property. Two heap order properties are as follows:
Max Heap Property:

All the parent node keys must be greater than or equal to their child node keys in max-heaps. So the root node will always contain the largest element in the Heap. If Node A has a child node B, then,

key(A) >=key(B)key(A)>=key(B)



Min Heap Property:

In Min-Heaps, all the parent node keys are less than or equal to their child node keys. So the root node, in this case, will always contain the smallest element present in the Heap. If Node A has a child node B, then:

key(A) <=key(B)key(A)<=key(B)
